{"ast":null,"code":"import objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport { parseValue } from '../language/parser';\nimport { GraphQLDirective } from '../type/directives';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { introspectionTypes, TypeKind } from '../type/introspection';\nimport { GraphQLSchema } from '../type/schema';\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from '../type/definition';\nimport { valueFromAST } from './valueFromAST';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(0, 'Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ' + inspect(introspection)); // Get the schema from the introspection result.\n\n  var schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  var typeMap = keyValMap(schemaIntrospection.types, function (typeIntrospection) {\n    return typeIntrospection.name;\n  }, function (typeIntrospection) {\n    return buildType(typeIntrospection);\n  });\n\n  for (var _i2 = 0, _ref2 = [].concat(specifiedScalarTypes, introspectionTypes); _i2 < _ref2.length; _i2++) {\n    var stdType = _ref2[_i2];\n\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: objectValues(typeMap),\n    directives: directives,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    if (!typeRef.name) {\n      throw new Error('Unknown type reference: ' + inspect(typeRef));\n    }\n\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    var type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure that a full introspection query is used in order to build a client schema.\"));\n    }\n\n    return type;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n\n    if (isInputType(type)) {\n      return type;\n    }\n\n    throw new Error('Introspection must provide input type for arguments, but received: ' + inspect(type) + '.');\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n\n    if (isOutputType(type)) {\n      return type;\n    }\n\n    throw new Error('Introspection must provide output type for fields, but received: ' + inspect(type) + '.');\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    return assertObjectType(type);\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    return assertInterfaceType(type);\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type && type.name && type.kind) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    throw new Error('Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema:' + inspect(type));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    if (!objectIntrospection.interfaces) {\n      throw new Error('Introspection result missing interfaces: ' + inspect(objectIntrospection));\n    }\n\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return objectIntrospection.interfaces.map(getInterfaceType);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      throw new Error('Introspection result missing possibleTypes: ' + inspect(unionIntrospection));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      throw new Error('Introspection result missing enumValues: ' + inspect(enumIntrospection));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      throw new Error('Introspection result missing inputFields: ' + inspect(inputObjectIntrospection));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error('Introspection result missing fields: ' + inspect(typeIntrospection));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      if (!fieldIntrospection.args) {\n        throw new Error('Introspection result missing field args: ' + inspect(fieldIntrospection));\n      }\n\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      throw new Error('Introspection result missing directive args: ' + inspect(directiveIntrospection));\n    }\n\n    if (!directiveIntrospection.locations) {\n      throw new Error('Introspection result missing directive locations: ' + inspect(directiveIntrospection));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}","map":{"version":3,"sources":["/Users/austinhague/Full_Stack_UofR/Projects/shop-shop-till-you-drop/client/node_modules/graphql/utilities/buildClientSchema.mjs"],"names":["objectValues","inspect","devAssert","keyValMap","isObjectLike","parseValue","GraphQLDirective","specifiedScalarTypes","introspectionTypes","TypeKind","GraphQLSchema","isInputType","isOutputType","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","assertNullableType","assertObjectType","assertInterfaceType","valueFromAST","buildClientSchema","introspection","options","__schema","schemaIntrospection","typeMap","types","typeIntrospection","name","buildType","_i2","_ref2","concat","length","stdType","queryType","getObjectType","mutationType","subscriptionType","directives","map","buildDirective","query","mutation","subscription","assumeValid","allowedLegacyNames","getType","typeRef","kind","LIST","itemRef","ofType","Error","NON_NULL","nullableRef","nullableType","getNamedType","typeName","type","getInputType","getOutputType","getInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","scalarIntrospection","description","objectIntrospection","interfaces","fields","buildFieldDefMap","interfaceIntrospection","unionIntrospection","possibleTypes","enumIntrospection","enumValues","values","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","buildInputValueDefMap","fieldIntrospection","args","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","undefined","directiveIntrospection","locations","slice"],"mappings":"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","sourcesContent":["import objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport { parseValue } from '../language/parser';\nimport { GraphQLDirective } from '../type/directives';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { introspectionTypes, TypeKind } from '../type/introspection';\nimport { GraphQLSchema } from '../type/schema';\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from '../type/definition';\nimport { valueFromAST } from './valueFromAST';\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(0, 'Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ' + inspect(introspection)); // Get the schema from the introspection result.\n\n  var schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  var typeMap = keyValMap(schemaIntrospection.types, function (typeIntrospection) {\n    return typeIntrospection.name;\n  }, function (typeIntrospection) {\n    return buildType(typeIntrospection);\n  });\n\n  for (var _i2 = 0, _ref2 = [].concat(specifiedScalarTypes, introspectionTypes); _i2 < _ref2.length; _i2++) {\n    var stdType = _ref2[_i2];\n\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: objectValues(typeMap),\n    directives: directives,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    if (!typeRef.name) {\n      throw new Error('Unknown type reference: ' + inspect(typeRef));\n    }\n\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    var type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure that a full introspection query is used in order to build a client schema.\"));\n    }\n\n    return type;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n\n    if (isInputType(type)) {\n      return type;\n    }\n\n    throw new Error('Introspection must provide input type for arguments, but received: ' + inspect(type) + '.');\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n\n    if (isOutputType(type)) {\n      return type;\n    }\n\n    throw new Error('Introspection must provide output type for fields, but received: ' + inspect(type) + '.');\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    return assertObjectType(type);\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    return assertInterfaceType(type);\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type && type.name && type.kind) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    throw new Error('Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema:' + inspect(type));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    if (!objectIntrospection.interfaces) {\n      throw new Error('Introspection result missing interfaces: ' + inspect(objectIntrospection));\n    }\n\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return objectIntrospection.interfaces.map(getInterfaceType);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      throw new Error('Introspection result missing possibleTypes: ' + inspect(unionIntrospection));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      throw new Error('Introspection result missing enumValues: ' + inspect(enumIntrospection));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      throw new Error('Introspection result missing inputFields: ' + inspect(inputObjectIntrospection));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error('Introspection result missing fields: ' + inspect(typeIntrospection));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      if (!fieldIntrospection.args) {\n        throw new Error('Introspection result missing field args: ' + inspect(fieldIntrospection));\n      }\n\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      throw new Error('Introspection result missing directive args: ' + inspect(directiveIntrospection));\n    }\n\n    if (!directiveIntrospection.locations) {\n      throw new Error('Introspection result missing directive locations: ' + inspect(directiveIntrospection));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}