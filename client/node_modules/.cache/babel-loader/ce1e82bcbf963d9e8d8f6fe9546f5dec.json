{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\nimport { equal } from '@wry/equality';\nimport { mergeOptions } from \"../../core/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { canUseWeakMap, isNonEmptyArray, maybeDeepFreeze } from \"../../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function useQuery(query, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n\n  return useInternalState(useApolloClient(options.client), query).useQuery(options);\n}\nexport function useInternalState(client, query) {\n  var stateRef = useRef();\n\n  if (!stateRef.current || client !== stateRef.current.client || query !== stateRef.current.query) {\n    stateRef.current = new InternalState(client, query);\n  }\n\n  var state = stateRef.current;\n\n  var _a = useState(0),\n      _tick = _a[0],\n      setTick = _a[1];\n\n  state.forceUpdate = function () {\n    setTick(function (tick) {\n      return tick + 1;\n    });\n  };\n\n  return state;\n}\n\nvar InternalState = function () {\n  function InternalState(client, query) {\n    this.client = client;\n    this.query = query;\n    this.ssrDisabledResult = maybeDeepFreeze({\n      loading: true,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.loading\n    });\n    this.skipStandbyResult = maybeDeepFreeze({\n      loading: false,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.ready\n    });\n    this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();\n    verifyDocumentType(query, DocumentType.Query);\n  }\n\n  InternalState.prototype.forceUpdate = function () {};\n\n  InternalState.prototype.useQuery = function (options) {\n    var _this = this;\n\n    this.renderPromises = useContext(getApolloContext()).renderPromises;\n    this.useOptions(options);\n    var obsQuery = this.useObservableQuery();\n    var result = useSyncExternalStore(useCallback(function () {\n      if (_this.renderPromises) {\n        return function () {};\n      }\n\n      var onNext = function () {\n        var previousResult = _this.result;\n        var result = obsQuery.getCurrentResult();\n\n        if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && equal(previousResult.data, result.data)) {\n          return;\n        }\n\n        _this.setResult(result);\n      };\n\n      var onError = function (error) {\n        var last = obsQuery[\"last\"];\n        subscription.unsubscribe();\n\n        try {\n          obsQuery.resetLastResults();\n          subscription = obsQuery.subscribe(onNext, onError);\n        } finally {\n          obsQuery[\"last\"] = last;\n        }\n\n        if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n          throw error;\n        }\n\n        var previousResult = _this.result;\n\n        if (!previousResult || previousResult && previousResult.loading || !equal(error, previousResult.error)) {\n          _this.setResult({\n            data: previousResult && previousResult.data,\n            error: error,\n            loading: false,\n            networkStatus: NetworkStatus.error\n          });\n        }\n      };\n\n      var subscription = obsQuery.subscribe(onNext, onError);\n      return function () {\n        return subscription.unsubscribe();\n      };\n    }, [obsQuery, this.renderPromises, this.client.disableNetworkFetches]), function () {\n      return _this.getCurrentResult();\n    });\n    this.unsafeHandlePartialRefetch(result);\n    return this.toQueryResult(result);\n  };\n\n  InternalState.prototype.useOptions = function (options) {\n    var _a;\n\n    var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);\n    var currentWatchQueryOptions = this.watchQueryOptions;\n    var resolveFetchBlockingPromise;\n\n    if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        this.observable.reobserve(__assign({\n          fetchBlockingPromise: new Promise(function (resolve) {\n            resolveFetchBlockingPromise = resolve;\n          })\n        }, watchQueryOptions));\n        this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    useUnblockFetchEffect(this.renderPromises, resolveFetchBlockingPromise);\n    this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if ((this.renderPromises || this.client.disableNetworkFetches) && this.queryHookOptions.ssr === false) {\n      this.result = this.ssrDisabledResult;\n    } else if (this.queryHookOptions.skip || this.watchQueryOptions.fetchPolicy === 'standby') {\n      this.result = this.skipStandbyResult;\n    } else if (this.result === this.ssrDisabledResult || this.result === this.skipStandbyResult) {\n      this.result = void 0;\n    }\n  };\n\n  InternalState.prototype.createWatchQueryOptions = function (_a) {\n    if (_a === void 0) {\n      _a = {};\n    }\n\n    var skip = _a.skip,\n        ssr = _a.ssr,\n        onCompleted = _a.onCompleted,\n        onError = _a.onError,\n        displayName = _a.displayName,\n        defaultOptions = _a.defaultOptions,\n        otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"displayName\", \"defaultOptions\"]);\n\n    var toMerge = [];\n    var globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n    if (defaultOptions) toMerge.push(defaultOptions);\n    var latestOptions = this.observable && this.observable.options;\n\n    if (latestOptions && toMerge.length) {\n      var defaults_1 = toMerge.reduce(mergeOptions, Object.create(null));\n      toMerge.length = 1;\n      toMerge[0] = defaults_1;\n      Object.keys(defaults_1).forEach(function (defaultOptionName) {\n        var currentOptionValue = latestOptions[defaultOptionName];\n\n        if (hasOwnProperty.call(latestOptions, defaultOptionName) && !equal(defaults_1[defaultOptionName], currentOptionValue)) {\n          defaults_1[defaultOptionName] = defaultOptionName === \"variables\" ? __assign(__assign({}, defaults_1.variables), currentOptionValue) : currentOptionValue;\n        }\n      });\n    }\n\n    toMerge.push(otherOptions);\n    var merged = toMerge.reduce(mergeOptions, Object.create(null));\n    var watchQueryOptions = Object.assign(merged, {\n      query: this.query\n    });\n\n    if (this.renderPromises && (watchQueryOptions.fetchPolicy === 'network-only' || watchQueryOptions.fetchPolicy === 'cache-and-network')) {\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    }\n\n    if (skip) {\n      var _b = watchQueryOptions.initialFetchPolicy,\n          initialFetchPolicy = _b === void 0 ? watchQueryOptions.fetchPolicy : _b;\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy: initialFetchPolicy,\n        fetchPolicy: 'standby'\n      });\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {};\n    }\n\n    return watchQueryOptions;\n  };\n\n  InternalState.prototype.onCompleted = function (data) {};\n\n  InternalState.prototype.onError = function (error) {};\n\n  InternalState.prototype.useObservableQuery = function () {\n    var resolveFetchBlockingPromise;\n    var obsQuery = this.observable = this.renderPromises && this.renderPromises.getSSRObservable(this.watchQueryOptions) || this.observable || this.client.watchQuery(__assign({\n      fetchBlockingPromise: new Promise(function (resolve) {\n        resolveFetchBlockingPromise = resolve;\n      })\n    }, this.watchQueryOptions));\n    useUnblockFetchEffect(this.renderPromises, resolveFetchBlockingPromise);\n    this.obsQueryFields = useMemo(function () {\n      return {\n        refetch: obsQuery.refetch.bind(obsQuery),\n        reobserve: obsQuery.reobserve.bind(obsQuery),\n        fetchMore: obsQuery.fetchMore.bind(obsQuery),\n        updateQuery: obsQuery.updateQuery.bind(obsQuery),\n        startPolling: obsQuery.startPolling.bind(obsQuery),\n        stopPolling: obsQuery.stopPolling.bind(obsQuery),\n        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)\n      };\n    }, [obsQuery]);\n\n    if (this.renderPromises) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n      var ssrAllowed = !(this.queryHookOptions.ssr === false || this.queryHookOptions.skip);\n\n      if (ssrAllowed && obsQuery.getCurrentResult().loading) {\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  };\n\n  InternalState.prototype.setResult = function (nextResult) {\n    var previousResult = this.result;\n\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n\n    this.result = nextResult;\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult);\n  };\n\n  InternalState.prototype.handleErrorOrCompleted = function (result) {\n    if (!result.loading) {\n      if (result.error) {\n        this.onError(result.error);\n      } else if (result.data) {\n        this.onCompleted(result.data);\n      }\n    }\n  };\n\n  InternalState.prototype.getCurrentResult = function () {\n    if (!this.result) {\n      this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());\n    }\n\n    return this.result;\n  };\n\n  InternalState.prototype.toQueryResult = function (result) {\n    var queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    var data = result.data,\n        partial = result.partial,\n        resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n\n    this.toQueryResultCache.set(result, queryResult = __assign(__assign(__assign({\n      data: data\n    }, resultWithoutPartial), this.obsQueryFields), {\n      client: this.client,\n      observable: this.observable,\n      variables: this.observable.variables,\n      called: true,\n      previousData: this.previousData\n    }));\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      queryResult.error = new ApolloError({\n        graphQLErrors: result.errors\n      });\n    }\n\n    return queryResult;\n  };\n\n  InternalState.prototype.unsafeHandlePartialRefetch = function (result) {\n    if (result.partial && this.queryHookOptions.partialRefetch && !result.loading && (!result.data || Object.keys(result.data).length === 0) && this.observable.options.fetchPolicy !== 'cache-only') {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch\n      });\n      this.observable.refetch();\n    }\n  };\n\n  return InternalState;\n}();\n\nfunction useUnblockFetchEffect(renderPromises, resolveFetchBlockingPromise) {\n  if (resolveFetchBlockingPromise) {\n    if (renderPromises) {\n      resolveFetchBlockingPromise(true);\n    } else {\n      setTimeout(function () {\n        return resolveFetchBlockingPromise(false);\n      }, 5000);\n    }\n  }\n\n  useEffect(function () {\n    if (resolveFetchBlockingPromise) {\n      resolveFetchBlockingPromise(true);\n    }\n  }, [resolveFetchBlockingPromise]);\n}","map":{"version":3,"mappings":"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","names":["useCallback","useContext","useEffect","useMemo","useRef","useState","useSyncExternalStore","equal","mergeOptions","getApolloContext","ApolloError","NetworkStatus","DocumentType","verifyDocumentType","useApolloClient","canUseWeakMap","isNonEmptyArray","maybeDeepFreeze","Object","hasOwnProperty","useQuery","query","options","create","useInternalState","client","stateRef","current","InternalState","state","_tick","setTick","forceUpdate","loading","data","error","networkStatus","ready","WeakMap","Map","Query","renderPromises","useOptions","obsQuery","useObservableQuery","result","_this","onNext","previousResult","getCurrentResult","setResult","onError","last","subscription","unsubscribe","resetLastResults","subscribe","call","disableNetworkFetches","unsafeHandlePartialRefetch","toQueryResult","watchQueryOptions","createWatchQueryOptions","queryHookOptions","currentWatchQueryOptions","resolveFetchBlockingPromise","observable","reobserve","__assign","fetchBlockingPromise","Promise","resolve","previousData","_a","useUnblockFetchEffect","onCompleted","prototype","ssr","ssrDisabledResult","skip","fetchPolicy","skipStandbyResult","displayName","defaultOptions","otherOptions","toMerge","globalDefaults","watchQuery","push","latestOptions","length","defaults_1","reduce","keys","forEach","defaultOptionName","currentOptionValue","variables","merged","assign","_b","initialFetchPolicy","getSSRObservable","obsQueryFields","refetch","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","registerSSRObservable","ssrAllowed","addObservableQueryPromise","nextResult","handleErrorOrCompleted","queryResult","toQueryResultCache","get","partial","resultWithoutPartial","set","called","errors","graphQLErrors","partialRefetch","setTimeout"],"sourceRoot":"","sources":["../../../src/react/hooks/useQuery.ts"],"sourcesContent":["import {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\nimport { equal } from '@wry/equality';\n\nimport { mergeOptions, OperationVariables } from '../../core';\nimport { ApolloContextValue, getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloClient,\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\nimport { canUseWeakMap, isNonEmptyArray, maybeDeepFreeze } from '../../utilities';\n\nconst {\n  prototype: {\n    hasOwnProperty,\n  },\n} = Object;\n\nexport function useQuery<\n  TData = any,\n  TVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = Object.create(null),\n): QueryResult<TData, TVariables> {\n  return useInternalState(\n    useApolloClient(options.client),\n    query,\n  ).useQuery(options);\n}\n\nexport function useInternalState<TData, TVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n): InternalState<TData, TVariables> {\n  const stateRef = useRef<InternalState<TData, TVariables>>();\n  if (\n    !stateRef.current ||\n    client !== stateRef.current.client ||\n    query !== stateRef.current.query\n  ) {\n    stateRef.current = new InternalState(client, query);\n  }\n  const state = stateRef.current;\n\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n  const [_tick, setTick] = useState(0);\n  state.forceUpdate = () => {\n    setTick(tick => tick + 1);\n  };\n\n  return state;\n}\n\nclass InternalState<TData, TVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n  }\n\n  forceUpdate() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n  }\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    this.renderPromises = useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    const result = useSyncExternalStore(\n      useCallback(() => {\n        if (this.renderPromises) {\n          return () => {};\n        }\n\n        const onNext = () => {\n          const previousResult = this.result;\n          // We use `getCurrentResult()` instead of the onNext argument because\n          // the values differ slightly. Specifically, loading results will have\n          // an empty object for data instead of `undefined` for some reason.\n          const result = obsQuery.getCurrentResult();\n          // Make sure we're not attempting to re-render similar results\n          if (\n            previousResult &&\n            previousResult.loading === result.loading &&\n            previousResult.networkStatus === result.networkStatus &&\n            equal(previousResult.data, result.data)\n          ) {\n            return;\n          }\n\n          this.setResult(result);\n        };\n\n        const onError = (error: Error) => {\n          const last = obsQuery[\"last\"];\n          subscription.unsubscribe();\n          // Unfortunately, if `lastError` is set in the current\n          // `observableQuery` when the subscription is re-created,\n          // the subscription will immediately receive the error, which will\n          // cause it to terminate again. To avoid this, we first clear\n          // the last error/result from the `observableQuery` before re-starting\n          // the subscription, and restore it afterwards (so the subscription\n          // has a chance to stay open).\n          try {\n            obsQuery.resetLastResults();\n            subscription = obsQuery.subscribe(onNext, onError);\n          } finally {\n            obsQuery[\"last\"] = last;\n          }\n\n          if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n            // The error is not a GraphQL error\n            throw error;\n          }\n\n          const previousResult = this.result;\n          if (\n            !previousResult ||\n            (previousResult && previousResult.loading) ||\n            !equal(error, previousResult.error)\n          ) {\n            this.setResult({\n              data: (previousResult && previousResult.data) as TData,\n              error: error as ApolloError,\n              loading: false,\n              networkStatus: NetworkStatus.error,\n            });\n          }\n        };\n\n        let subscription = obsQuery.subscribe(onNext, onError);\n\n        return () => subscription.unsubscribe();\n      }, [\n        // We memoize the subscribe function using useCallback and the following\n        // dependency keys, because the subscribe function reference is all that\n        // useSyncExternalStore uses internally as a dependency key for the\n        // useEffect ultimately responsible for the subscription, so we are\n        // effectively passing this dependency array to that useEffect buried\n        // inside useSyncExternalStore, as desired.\n        obsQuery,\n        this.renderPromises,\n        this.client.disableNetworkFetches,\n      ]),\n\n      () => this.getCurrentResult(),\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    return this.toQueryResult(result);\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(\n    options: QueryHookOptions<TData, TVariables>,\n  ) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      this.queryHookOptions = options,\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n    let resolveFetchBlockingPromise: undefined | ((result: boolean) => any);\n\n    if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n      if (currentWatchQueryOptions && this.observable) {\n        // Though it might be tempting to postpone this setOptions call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that setOptions\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed). To prevent any risk of premature/unwanted\n        // network traffic, we use a fetchBlockingPromise, which will only be\n        // unblocked once the useEffect has fired.\n        this.observable.reobserve({\n          fetchBlockingPromise: new Promise<boolean>(resolve => {\n            resolveFetchBlockingPromise = resolve;\n          }),\n          // If watchQueryOptions.fetchBlockingPromise is also defined, it takes\n          // precedence over the fetchBlockingPromise we just created.\n          ...watchQueryOptions,\n        });\n\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    useUnblockFetchEffect(this.renderPromises, resolveFetchBlockingPromise);\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === 'standby'\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    displayName,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<TVariables, TData> {\n    // We use the mergeOptions helper function (which uses compact(...) and\n    // shallow-merges variables) to combine globalDefaults with any local\n    // defaultOptions provided to useQuery.\n    const toMerge: Partial<WatchQueryOptions<TVariables, TData>>[] = [];\n\n    // Merge global client.watchQuery default options with the lowest priority.\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    // Next, merge any defaultOptions passed directly to useQuery.\n    if (defaultOptions) toMerge.push(defaultOptions);\n\n    const latestOptions = this.observable && this.observable.options;\n    if (latestOptions && toMerge.length) {\n      // If we already have this.watchQueryOptions, those options should take\n      // precedence over default options of the same name. It might be simpler\n      // to do toMerge.push(this.watchQueryOptions), but that potentially\n      // (re)injects unrelated/unwanted options. Passing Object.create(null) as\n      // the second argument to toMerge.reduce ensures the result is a newly\n      // created object, so we can safely modify it in the forEach loop below.\n      const defaults = toMerge.reduce(mergeOptions, Object.create(null));\n\n      // Compact the toMerge array to hold only the merged defaults. This is\n      // equivalent to toMerge.splice(0, toMerge.length, defaults).\n      toMerge.length = 1;\n      toMerge[0] = defaults;\n\n      Object.keys(defaults).forEach(\n        (defaultOptionName: keyof WatchQueryOptions<TVariables, TData>) => {\n          const currentOptionValue = latestOptions[defaultOptionName];\n          if (\n            hasOwnProperty.call(latestOptions, defaultOptionName) &&\n            !equal(defaults[defaultOptionName], currentOptionValue)\n          ) {\n            // If you keep passing useQuery({ defaultOptions: { variables }}),\n            // those default variables continue to provide their default values\n            // every time, though in most cases this.watchQueryOptions.variables\n            // will have a current value for every default variable name, so the\n            // defaults don't matter. However, if a variable has been removed\n            // from this.watchQueryOptions.variables, future useQuery calls can\n            // restore its default value from defaultOptions.variables.\n            defaults[defaultOptionName] = defaultOptionName === \"variables\"\n              ? { ...defaults.variables, ...currentOptionValue }\n              : currentOptionValue;\n          }\n        },\n      );\n    }\n\n    // Give highest precedence to any non-default WatchQueryOptions passed\n    // directly to useQuery.\n    toMerge.push(otherOptions);\n\n    const merged = toMerge.reduce(mergeOptions, Object.create(null));\n\n    // This Object.assign is safe because merged is the fresh object created by\n    // the Object.create(null) argument to toMerge.reduce.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(merged, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (\n        watchQueryOptions.fetchPolicy === 'network-only' ||\n        watchQueryOptions.fetchPolicy === 'cache-and-network'\n      )\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    } else if (!watchQueryOptions.fetchPolicy) {\n      // We applied all available fetchPolicy default values above (from\n      // globalDefaults and defaultOptions), so, if fetchPolicy is still\n      // undefined, fall back to the default default (no typo), cache-first.\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    }\n\n    if (skip) {\n      const {\n        // The watchQueryOptions.initialFetchPolicy field usually defaults to\n        // watchQueryOptions.fetchPolicy, which has now been properly\n        // defaulted/initialized. However, watchQueryOptions.initialFetchPolicy\n        // can be provided explicitly instead, if more control is desired.\n        initialFetchPolicy = watchQueryOptions.fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: 'standby',\n      });\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    return watchQueryOptions;\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable: ObservableQuery<TData, TVariables>;\n  private obsQueryFields: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    let resolveFetchBlockingPromise: undefined | ((result: boolean) => any);\n\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = this.observable =\n      this.renderPromises\n        && this.renderPromises.getSSRObservable(this.watchQueryOptions)\n        || this.observable // Reuse this.observable if possible (and not SSR)\n        || this.client.watchQuery({\n          fetchBlockingPromise: new Promise<boolean>(resolve => {\n            resolveFetchBlockingPromise = resolve;\n          }),\n          ...this.watchQueryOptions,\n        });\n\n    useUnblockFetchEffect(this.renderPromises, resolveFetchBlockingPromise);\n\n    this.obsQueryFields = useMemo(() => ({\n      refetch: obsQuery.refetch.bind(obsQuery),\n      reobserve: obsQuery.reobserve.bind(obsQuery),\n      fetchMore: obsQuery.fetchMore.bind(obsQuery),\n      updateQuery: obsQuery.updateQuery.bind(obsQuery),\n      startPolling: obsQuery.startPolling.bind(obsQuery),\n      stopPolling: obsQuery.stopPolling.bind(obsQuery),\n      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n    }), [obsQuery]);\n\n    if (this.renderPromises) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      const ssrAllowed = !(\n        this.queryHookOptions.ssr === false ||\n        this.queryHookOptions.skip\n      );\n\n      if (ssrAllowed && obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult);\n  }\n\n  private handleErrorOrCompleted(result: ApolloQueryResult<TData>) {\n    if (!result.loading) {\n      if (result.error) {\n        this.onError(result.error);\n      } else if (result.data) {\n        this.onCompleted(result.data);\n      }\n    }\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        this.result = this.observable.getCurrentResult()\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>,\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(result, queryResult = {\n      data, // Ensure always defined, even if result.data is missing.\n      ...resultWithoutPartial,\n      ...this.obsQueryFields,\n      client: this.client,\n      observable: this.observable,\n      variables: this.observable.variables,\n      called: true,\n      previousData: this.previousData,\n    });\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== 'cache-only'\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n\nfunction useUnblockFetchEffect<TData, TVars>(\n  renderPromises: ApolloContextValue[\"renderPromises\"],\n  resolveFetchBlockingPromise?: (result: boolean) => any,\n) {\n  if (resolveFetchBlockingPromise) {\n    if (renderPromises) {\n      // Since we're doing SSR, the useEffect callback will not be called, so we\n      // must unblock the fetchBlockingPromise now.\n      resolveFetchBlockingPromise(true);\n    } else {\n      // Otherwise, silently discard blocked fetches whose useEffect callbacks\n      // have not fired within 5 seconds (more than enough time to mount).\n      setTimeout(() => resolveFetchBlockingPromise(false), 5000);\n    }\n  }\n\n  useEffect(() => {\n    if (resolveFetchBlockingPromise) {\n      resolveFetchBlockingPromise(true);\n    }\n  }, [resolveFetchBlockingPromise]);\n}\n"]},"metadata":{},"sourceType":"module"}