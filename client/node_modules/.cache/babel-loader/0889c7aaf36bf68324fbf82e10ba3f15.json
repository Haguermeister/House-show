{"ast":null,"code":"import objectValues from '../polyfills/objectValues';\nimport keyMap from '../jsutils/keyMap';\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport { Kind } from '../language/kinds';\nimport { TokenKind } from '../language/tokenKind';\nimport { parse } from '../language/parser';\nimport { isTypeDefinitionNode } from '../language/predicates';\nimport { dedentBlockStringValue } from '../language/blockString';\nimport { assertValidSDL } from '../validation/validate';\nimport { getDirectiveValues } from '../execution/values';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { introspectionTypes } from '../type/introspection';\nimport { GraphQLSchema } from '../type/schema';\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\nimport { GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';\nimport { valueFromAST } from './valueFromAST';\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function buildASTSchema(documentAST, options) {\n  documentAST && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST');\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDL(documentAST);\n  }\n\n  var schemaDef;\n  var typeDefs = [];\n  var directiveDefs = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n\n  var astBuilder = new ASTDefinitionBuilder(options, function (typeName) {\n    var type = typeMap[typeName];\n\n    if (type === undefined) {\n      throw new Error(\"Type \\\"\".concat(typeName, \"\\\" not found in document.\"));\n    }\n\n    return type;\n  });\n  var typeMap = keyByNameNode(typeDefs, function (node) {\n    return astBuilder.buildType(node);\n  });\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: 'Query',\n    mutation: 'Mutation',\n    subscription: 'Subscription'\n  };\n  var directives = directiveDefs.map(function (def) {\n    return astBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  return new GraphQLSchema({\n    // Note: While this could make early assertions to get the correctly\n    // typed values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    query: operationTypes.query ? typeMap[operationTypes.query] : null,\n    mutation: operationTypes.mutation ? typeMap[operationTypes.mutation] : null,\n    subscription: operationTypes.subscription ? typeMap[operationTypes.subscription] : null,\n    types: objectValues(typeMap),\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n\n  function getOperationTypes(schema) {\n    var opTypes = {};\n\n    for (var _i4 = 0, _schema$operationType2 = schema.operationTypes; _i4 < _schema$operationType2.length; _i4++) {\n      var operationType = _schema$operationType2[_i4];\n      opTypes[operationType.operation] = operationType.type.name.value;\n    }\n\n    return opTypes;\n  }\n}\nvar stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n  return type.name;\n});\nexport var ASTDefinitionBuilder = /*#__PURE__*/function () {\n  function ASTDefinitionBuilder(options, resolveType) {\n    this._options = options;\n    this._resolveType = resolveType;\n  }\n\n  var _proto = ASTDefinitionBuilder.prototype;\n\n  _proto.getNamedType = function getNamedType(node) {\n    var name = node.name.value;\n    return stdTypeMap[name] || this._resolveType(name);\n  };\n\n  _proto.getWrappedType = function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(this.getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(this.getWrappedType(node.type));\n    }\n\n    return this.getNamedType(node);\n  };\n\n  _proto.buildDirective = function buildDirective(directive) {\n    var _this = this;\n\n    var locations = directive.locations.map(function (_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return new GraphQLDirective({\n      name: directive.name.value,\n      description: getDescription(directive, this._options),\n      locations: locations,\n      isRepeatable: directive.repeatable,\n      args: keyByNameNode(directive.arguments || [], function (arg) {\n        return _this.buildArg(arg);\n      }),\n      astNode: directive\n    });\n  };\n\n  _proto.buildField = function buildField(field) {\n    var _this2 = this;\n\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this.getWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: keyByNameNode(field.arguments || [], function (arg) {\n        return _this2.buildArg(arg);\n      }),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n\n  _proto.buildArg = function buildArg(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    // with validateSchema() will produce more actionable results.\n    var type = this.getWrappedType(value.type);\n    return {\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildInputField = function buildInputField(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    // with validateSchema() will produce more actionable results.\n    var type = this.getWrappedType(value.type);\n    return {\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildEnumValue = function buildEnumValue(value) {\n    return {\n      description: getDescription(value, this._options),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    };\n  };\n\n  _proto.buildType = function buildType(astNode) {\n    var name = astNode.name.value;\n\n    if (stdTypeMap[name]) {\n      return stdTypeMap[name];\n    }\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(astNode);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(astNode);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(astNode);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(astNode);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(astNode);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(astNode);\n    } // Not reachable. All possible type definition nodes have been considered.\n\n    /* istanbul ignore next */\n\n\n    invariant(false, 'Unexpected type definition node: ' + inspect(astNode));\n  };\n\n  _proto._makeTypeDef = function _makeTypeDef(astNode) {\n    var _this3 = this;\n\n    var interfaceNodes = astNode.interfaces;\n    var fieldNodes = astNode.fields; // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n    var interfaces = interfaceNodes && interfaceNodes.length > 0 ? function () {\n      return interfaceNodes.map(function (ref) {\n        return _this3.getNamedType(ref);\n      });\n    } : [];\n    var fields = fieldNodes && fieldNodes.length > 0 ? function () {\n      return keyByNameNode(fieldNodes, function (field) {\n        return _this3.buildField(field);\n      });\n    } : Object.create(null);\n    return new GraphQLObjectType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      interfaces: interfaces,\n      fields: fields,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeInterfaceDef = function _makeInterfaceDef(astNode) {\n    var _this4 = this;\n\n    var fieldNodes = astNode.fields;\n    var fields = fieldNodes && fieldNodes.length > 0 ? function () {\n      return keyByNameNode(fieldNodes, function (field) {\n        return _this4.buildField(field);\n      });\n    } : Object.create(null);\n    return new GraphQLInterfaceType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      fields: fields,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeEnumDef = function _makeEnumDef(astNode) {\n    var _this5 = this;\n\n    var valueNodes = astNode.values || [];\n    return new GraphQLEnumType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      values: keyByNameNode(valueNodes, function (value) {\n        return _this5.buildEnumValue(value);\n      }),\n      astNode: astNode\n    });\n  };\n\n  _proto._makeUnionDef = function _makeUnionDef(astNode) {\n    var _this6 = this;\n\n    var typeNodes = astNode.types; // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n    var types = typeNodes && typeNodes.length > 0 ? function () {\n      return typeNodes.map(function (ref) {\n        return _this6.getNamedType(ref);\n      });\n    } : [];\n    return new GraphQLUnionType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      types: types,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeScalarDef = function _makeScalarDef(astNode) {\n    return new GraphQLScalarType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      astNode: astNode\n    });\n  };\n\n  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this7 = this;\n\n    var fields = def.fields;\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: fields ? function () {\n        return keyByNameNode(fields, function (field) {\n          return _this7.buildInputField(field);\n        });\n      } : Object.create(null),\n      astNode: def\n    });\n  };\n\n  return ASTDefinitionBuilder;\n}();\n\nfunction keyByNameNode(list, valFn) {\n  return keyValMap(list, function (_ref2) {\n    var name = _ref2.name;\n    return name.value;\n  }, valFn);\n}\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nexport function buildSchema(source, options) {\n  return buildASTSchema(parse(source, options), options);\n}","map":{"version":3,"sources":["/Users/austinhague/Full_Stack_UofR/Projects/shop-shop-till-you-drop/client/node_modules/graphql/utilities/buildASTSchema.mjs"],"names":["objectValues","keyMap","inspect","invariant","devAssert","keyValMap","Kind","TokenKind","parse","isTypeDefinitionNode","dedentBlockStringValue","assertValidSDL","getDirectiveValues","specifiedScalarTypes","introspectionTypes","GraphQLSchema","GraphQLDirective","GraphQLSkipDirective","GraphQLIncludeDirective","GraphQLDeprecatedDirective","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","valueFromAST","buildASTSchema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","schemaDef","typeDefs","directiveDefs","_i2","_documentAST$definiti2","definitions","length","def","SCHEMA_DEFINITION","push","DIRECTIVE_DEFINITION","astBuilder","ASTDefinitionBuilder","typeName","type","typeMap","undefined","Error","concat","keyByNameNode","node","buildType","operationTypes","getOperationTypes","query","mutation","subscription","directives","map","buildDirective","some","directive","name","types","astNode","allowedLegacyNames","schema","opTypes","_i4","_schema$operationType2","operationType","operation","value","stdTypeMap","resolveType","_options","_resolveType","_proto","prototype","getNamedType","getWrappedType","LIST_TYPE","NON_NULL_TYPE","_this","locations","_ref","description","getDescription","isRepeatable","repeatable","args","arguments","arg","buildArg","buildField","field","_this2","deprecationReason","getDeprecationReason","defaultValue","buildInputField","buildEnumValue","OBJECT_TYPE_DEFINITION","_makeTypeDef","INTERFACE_TYPE_DEFINITION","_makeInterfaceDef","ENUM_TYPE_DEFINITION","_makeEnumDef","UNION_TYPE_DEFINITION","_makeUnionDef","SCALAR_TYPE_DEFINITION","_makeScalarDef","INPUT_OBJECT_TYPE_DEFINITION","_makeInputObjectDef","_this3","interfaceNodes","interfaces","fieldNodes","fields","ref","Object","create","_this4","_this5","valueNodes","values","_this6","typeNodes","_this7","list","valFn","_ref2","deprecated","reason","commentDescriptions","rawValue","getLeadingCommentBlock","loc","comments","token","startToken","prev","COMMENT","next","line","String","reverse","join","buildSchema","source"],"mappings":"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","sourcesContent":["import objectValues from '../polyfills/objectValues';\nimport keyMap from '../jsutils/keyMap';\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport { Kind } from '../language/kinds';\nimport { TokenKind } from '../language/tokenKind';\nimport { parse } from '../language/parser';\nimport { isTypeDefinitionNode } from '../language/predicates';\nimport { dedentBlockStringValue } from '../language/blockString';\nimport { assertValidSDL } from '../validation/validate';\nimport { getDirectiveValues } from '../execution/values';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { introspectionTypes } from '../type/introspection';\nimport { GraphQLSchema } from '../type/schema';\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\nimport { GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';\nimport { valueFromAST } from './valueFromAST';\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  documentAST && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST');\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDL(documentAST);\n  }\n\n  var schemaDef;\n  var typeDefs = [];\n  var directiveDefs = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n\n  var astBuilder = new ASTDefinitionBuilder(options, function (typeName) {\n    var type = typeMap[typeName];\n\n    if (type === undefined) {\n      throw new Error(\"Type \\\"\".concat(typeName, \"\\\" not found in document.\"));\n    }\n\n    return type;\n  });\n  var typeMap = keyByNameNode(typeDefs, function (node) {\n    return astBuilder.buildType(node);\n  });\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: 'Query',\n    mutation: 'Mutation',\n    subscription: 'Subscription'\n  };\n  var directives = directiveDefs.map(function (def) {\n    return astBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  return new GraphQLSchema({\n    // Note: While this could make early assertions to get the correctly\n    // typed values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    query: operationTypes.query ? typeMap[operationTypes.query] : null,\n    mutation: operationTypes.mutation ? typeMap[operationTypes.mutation] : null,\n    subscription: operationTypes.subscription ? typeMap[operationTypes.subscription] : null,\n    types: objectValues(typeMap),\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n\n  function getOperationTypes(schema) {\n    var opTypes = {};\n\n    for (var _i4 = 0, _schema$operationType2 = schema.operationTypes; _i4 < _schema$operationType2.length; _i4++) {\n      var operationType = _schema$operationType2[_i4];\n      opTypes[operationType.operation] = operationType.type.name.value;\n    }\n\n    return opTypes;\n  }\n}\nvar stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n  return type.name;\n});\nexport var ASTDefinitionBuilder =\n/*#__PURE__*/\nfunction () {\n  function ASTDefinitionBuilder(options, resolveType) {\n    this._options = options;\n    this._resolveType = resolveType;\n  }\n\n  var _proto = ASTDefinitionBuilder.prototype;\n\n  _proto.getNamedType = function getNamedType(node) {\n    var name = node.name.value;\n    return stdTypeMap[name] || this._resolveType(name);\n  };\n\n  _proto.getWrappedType = function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(this.getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(this.getWrappedType(node.type));\n    }\n\n    return this.getNamedType(node);\n  };\n\n  _proto.buildDirective = function buildDirective(directive) {\n    var _this = this;\n\n    var locations = directive.locations.map(function (_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return new GraphQLDirective({\n      name: directive.name.value,\n      description: getDescription(directive, this._options),\n      locations: locations,\n      isRepeatable: directive.repeatable,\n      args: keyByNameNode(directive.arguments || [], function (arg) {\n        return _this.buildArg(arg);\n      }),\n      astNode: directive\n    });\n  };\n\n  _proto.buildField = function buildField(field) {\n    var _this2 = this;\n\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this.getWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: keyByNameNode(field.arguments || [], function (arg) {\n        return _this2.buildArg(arg);\n      }),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n\n  _proto.buildArg = function buildArg(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    // with validateSchema() will produce more actionable results.\n    var type = this.getWrappedType(value.type);\n    return {\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildInputField = function buildInputField(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    // with validateSchema() will produce more actionable results.\n    var type = this.getWrappedType(value.type);\n    return {\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildEnumValue = function buildEnumValue(value) {\n    return {\n      description: getDescription(value, this._options),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    };\n  };\n\n  _proto.buildType = function buildType(astNode) {\n    var name = astNode.name.value;\n\n    if (stdTypeMap[name]) {\n      return stdTypeMap[name];\n    }\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(astNode);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(astNode);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(astNode);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(astNode);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(astNode);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(astNode);\n    } // Not reachable. All possible type definition nodes have been considered.\n\n\n    /* istanbul ignore next */\n    invariant(false, 'Unexpected type definition node: ' + inspect(astNode));\n  };\n\n  _proto._makeTypeDef = function _makeTypeDef(astNode) {\n    var _this3 = this;\n\n    var interfaceNodes = astNode.interfaces;\n    var fieldNodes = astNode.fields; // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n    var interfaces = interfaceNodes && interfaceNodes.length > 0 ? function () {\n      return interfaceNodes.map(function (ref) {\n        return _this3.getNamedType(ref);\n      });\n    } : [];\n    var fields = fieldNodes && fieldNodes.length > 0 ? function () {\n      return keyByNameNode(fieldNodes, function (field) {\n        return _this3.buildField(field);\n      });\n    } : Object.create(null);\n    return new GraphQLObjectType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      interfaces: interfaces,\n      fields: fields,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeInterfaceDef = function _makeInterfaceDef(astNode) {\n    var _this4 = this;\n\n    var fieldNodes = astNode.fields;\n    var fields = fieldNodes && fieldNodes.length > 0 ? function () {\n      return keyByNameNode(fieldNodes, function (field) {\n        return _this4.buildField(field);\n      });\n    } : Object.create(null);\n    return new GraphQLInterfaceType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      fields: fields,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeEnumDef = function _makeEnumDef(astNode) {\n    var _this5 = this;\n\n    var valueNodes = astNode.values || [];\n    return new GraphQLEnumType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      values: keyByNameNode(valueNodes, function (value) {\n        return _this5.buildEnumValue(value);\n      }),\n      astNode: astNode\n    });\n  };\n\n  _proto._makeUnionDef = function _makeUnionDef(astNode) {\n    var _this6 = this;\n\n    var typeNodes = astNode.types; // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n    var types = typeNodes && typeNodes.length > 0 ? function () {\n      return typeNodes.map(function (ref) {\n        return _this6.getNamedType(ref);\n      });\n    } : [];\n    return new GraphQLUnionType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      types: types,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeScalarDef = function _makeScalarDef(astNode) {\n    return new GraphQLScalarType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      astNode: astNode\n    });\n  };\n\n  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this7 = this;\n\n    var fields = def.fields;\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: fields ? function () {\n        return keyByNameNode(fields, function (field) {\n          return _this7.buildInputField(field);\n        });\n      } : Object.create(null),\n      astNode: def\n    });\n  };\n\n  return ASTDefinitionBuilder;\n}();\n\nfunction keyByNameNode(list, valFn) {\n  return keyValMap(list, function (_ref2) {\n    var name = _ref2.name;\n    return name.value;\n  }, valFn);\n}\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nexport function buildSchema(source, options) {\n  return buildASTSchema(parse(source, options), options);\n}\n"]},"metadata":{},"sourceType":"module"}