{"ast":null,"code":"import find from '../polyfills/find';\nimport objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport toObjMap from '../jsutils/toObjMap';\nimport devAssert from '../jsutils/devAssert';\nimport instanceOf from '../jsutils/instanceOf';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport { __Schema } from './introspection';\nimport { GraphQLDirective, isDirective, specifiedDirectives } from './directives';\nimport { isObjectType, isInterfaceType, isUnionType, isInputObjectType, getNamedType } from './definition';\n/**\n * Test if the given value is a GraphQL schema.\n */\n// eslint-disable-next-line no-redeclare\n\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(\"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\"));\n  }\n\n  return schema;\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n *     const characterInterface = new GraphQLInterfaceType({\n *       name: 'Character',\n *       ...\n *     });\n *\n *     const humanType = new GraphQLObjectType({\n *       name: 'Human',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const droidType = new GraphQLObjectType({\n *       name: 'Droid',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const schema = new GraphQLSchema({\n *       query: new GraphQLObjectType({\n *         name: 'Query',\n *         fields: {\n *           hero: { type: characterInterface, ... },\n *         }\n *       }),\n *       ...\n *       // Since this schema references only the `Character` interface it's\n *       // necessary to explicitly list the types that implement it if\n *       // you want them to be included in the final schema.\n *       types: [humanType, droidType],\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\nexport var GraphQLSchema = /*#__PURE__*/function () {\n  // Used as a cache for validateSchema().\n  // Referenced by validateSchema().\n  function GraphQLSchema(config) {\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    if (config && config.assumeValid) {\n      this.__validationErrors = [];\n    } else {\n      this.__validationErrors = undefined; // Otherwise check for common mistakes during construction to produce\n      // clear and early error messages.\n\n      isObjectLike(config) || devAssert(0, 'Must provide configuration object.');\n      !config.types || Array.isArray(config.types) || devAssert(0, \"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types), \".\"));\n      !config.directives || Array.isArray(config.directives) || devAssert(0, '\"directives\" must be Array if provided but got: ' + \"\".concat(inspect(config.directives), \".\"));\n      !config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames) || devAssert(0, '\"allowedLegacyNames\" must be Array if provided but got: ' + \"\".concat(inspect(config.allowedLegacyNames), \".\"));\n    }\n\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.__allowedLegacyNames = config.allowedLegacyNames || [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = config.directives || specifiedDirectives; // Build type map now to detect any errors within this schema.\n\n    var initialTypes = [this._queryType, this._mutationType, this._subscriptionType, __Schema].concat(config.types); // Keep track of all types referenced within the schema.\n\n    var typeMap = Object.create(null); // First by deeply visiting all initial types.\n\n    typeMap = initialTypes.reduce(typeMapReducer, typeMap); // Then by deeply visiting all directive types.\n\n    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = typeMap;\n    this._possibleTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementations = Object.create(null);\n\n    for (var _i2 = 0, _objectValues2 = objectValues(this._typeMap); _i2 < _objectValues2.length; _i2++) {\n      var type = _objectValues2[_i2];\n\n      if (isObjectType(type)) {\n        for (var _i4 = 0, _type$getInterfaces2 = type.getInterfaces(); _i4 < _type$getInterfaces2.length; _i4++) {\n          var iface = _type$getInterfaces2[_i4];\n\n          if (isInterfaceType(iface)) {\n            var impls = this._implementations[iface.name];\n\n            if (impls) {\n              impls.push(type);\n            } else {\n              this._implementations[iface.name] = [type];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var _proto = GraphQLSchema.prototype;\n\n  _proto.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  _proto.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  _proto.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  _proto.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  _proto.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (isUnionType(abstractType)) {\n      return abstractType.getTypes();\n    }\n\n    return this._implementations[abstractType.name] || [];\n  };\n\n  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    if (this._possibleTypeMap[abstractType.name] == null) {\n      var map = Object.create(null);\n\n      for (var _i6 = 0, _this$getPossibleType2 = this.getPossibleTypes(abstractType); _i6 < _this$getPossibleType2.length; _i6++) {\n        var type = _this$getPossibleType2[_i6];\n        map[type.name] = true;\n      }\n\n      this._possibleTypeMap[abstractType.name] = map;\n    }\n\n    return Boolean(this._possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n\n  _proto.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  _proto.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  _proto.toConfig = function toConfig() {\n    return {\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: objectValues(this.getTypeMap()),\n      directives: this.getDirectives().slice(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || [],\n      assumeValid: this.__validationErrors !== undefined,\n      allowedLegacyNames: this.__allowedLegacyNames\n    };\n  };\n\n  return GraphQLSchema;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLSchema);\n\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n\n  var namedType = getNamedType(type);\n  var seenType = map[namedType.name];\n\n  if (seenType) {\n    if (seenType !== namedType) {\n      throw new Error(\"Schema must contain uniquely named types but contains multiple types named \\\"\".concat(namedType.name, \"\\\".\"));\n    }\n\n    return map;\n  }\n\n  map[namedType.name] = namedType;\n  var reducedMap = map;\n\n  if (isUnionType(namedType)) {\n    reducedMap = namedType.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(namedType)) {\n    reducedMap = namedType.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(namedType) || isInterfaceType(namedType)) {\n    for (var _i8 = 0, _objectValues4 = objectValues(namedType.getFields()); _i8 < _objectValues4.length; _i8++) {\n      var field = _objectValues4[_i8];\n      var fieldArgTypes = field.args.map(function (arg) {\n        return arg.type;\n      });\n      reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    }\n  }\n\n  if (isInputObjectType(namedType)) {\n    for (var _i10 = 0, _objectValues6 = objectValues(namedType.getFields()); _i10 < _objectValues6.length; _i10++) {\n      var _field = _objectValues6[_i10];\n      reducedMap = typeMapReducer(reducedMap, _field.type);\n    }\n  }\n\n  return reducedMap;\n}\n\nfunction typeMapDirectiveReducer(map, directive) {\n  // Directives are not validated until validateSchema() is called.\n  if (!isDirective(directive)) {\n    return map;\n  }\n\n  return directive.args.reduce(function (_map, arg) {\n    return typeMapReducer(_map, arg.type);\n  }, map);\n}","map":{"version":3,"sources":["/Users/austinhague/Full_Stack_UofR/Projects/shop-shop-till-you-drop/client/node_modules/graphql/type/schema.mjs"],"names":["find","objectValues","inspect","toObjMap","devAssert","instanceOf","isObjectLike","defineToStringTag","__Schema","GraphQLDirective","isDirective","specifiedDirectives","isObjectType","isInterfaceType","isUnionType","isInputObjectType","getNamedType","isSchema","schema","GraphQLSchema","assertSchema","Error","concat","config","assumeValid","__validationErrors","undefined","types","Array","isArray","directives","allowedLegacyNames","extensions","astNode","extensionASTNodes","__allowedLegacyNames","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","_directives","initialTypes","typeMap","Object","create","reduce","typeMapReducer","typeMapDirectiveReducer","_typeMap","_possibleTypeMap","_implementations","_i2","_objectValues2","length","type","_i4","_type$getInterfaces2","getInterfaces","iface","impls","name","push","_proto","prototype","getQueryType","getMutationType","getSubscriptionType","getTypeMap","getType","getPossibleTypes","abstractType","getTypes","isPossibleType","possibleType","map","_i6","_this$getPossibleType2","Boolean","getDirectives","getDirective","directive","toConfig","slice","namedType","seenType","reducedMap","_i8","_objectValues4","getFields","field","fieldArgTypes","args","arg","_i10","_objectValues6","_field","_map"],"mappings":"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","sourcesContent":["import find from '../polyfills/find';\nimport objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport toObjMap from '../jsutils/toObjMap';\nimport devAssert from '../jsutils/devAssert';\nimport instanceOf from '../jsutils/instanceOf';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport { __Schema } from './introspection';\nimport { GraphQLDirective, isDirective, specifiedDirectives } from './directives';\nimport { isObjectType, isInterfaceType, isUnionType, isInputObjectType, getNamedType } from './definition';\n/**\n * Test if the given value is a GraphQL schema.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(\"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\"));\n  }\n\n  return schema;\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n *     const characterInterface = new GraphQLInterfaceType({\n *       name: 'Character',\n *       ...\n *     });\n *\n *     const humanType = new GraphQLObjectType({\n *       name: 'Human',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const droidType = new GraphQLObjectType({\n *       name: 'Droid',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const schema = new GraphQLSchema({\n *       query: new GraphQLObjectType({\n *         name: 'Query',\n *         fields: {\n *           hero: { type: characterInterface, ... },\n *         }\n *       }),\n *       ...\n *       // Since this schema references only the `Character` interface it's\n *       // necessary to explicitly list the types that implement it if\n *       // you want them to be included in the final schema.\n *       types: [humanType, droidType],\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\nexport var GraphQLSchema =\n/*#__PURE__*/\nfunction () {\n  // Used as a cache for validateSchema().\n  // Referenced by validateSchema().\n  function GraphQLSchema(config) {\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    if (config && config.assumeValid) {\n      this.__validationErrors = [];\n    } else {\n      this.__validationErrors = undefined; // Otherwise check for common mistakes during construction to produce\n      // clear and early error messages.\n\n      isObjectLike(config) || devAssert(0, 'Must provide configuration object.');\n      !config.types || Array.isArray(config.types) || devAssert(0, \"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types), \".\"));\n      !config.directives || Array.isArray(config.directives) || devAssert(0, '\"directives\" must be Array if provided but got: ' + \"\".concat(inspect(config.directives), \".\"));\n      !config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames) || devAssert(0, '\"allowedLegacyNames\" must be Array if provided but got: ' + \"\".concat(inspect(config.allowedLegacyNames), \".\"));\n    }\n\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.__allowedLegacyNames = config.allowedLegacyNames || [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = config.directives || specifiedDirectives; // Build type map now to detect any errors within this schema.\n\n    var initialTypes = [this._queryType, this._mutationType, this._subscriptionType, __Schema].concat(config.types); // Keep track of all types referenced within the schema.\n\n    var typeMap = Object.create(null); // First by deeply visiting all initial types.\n\n    typeMap = initialTypes.reduce(typeMapReducer, typeMap); // Then by deeply visiting all directive types.\n\n    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = typeMap;\n    this._possibleTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementations = Object.create(null);\n\n    for (var _i2 = 0, _objectValues2 = objectValues(this._typeMap); _i2 < _objectValues2.length; _i2++) {\n      var type = _objectValues2[_i2];\n\n      if (isObjectType(type)) {\n        for (var _i4 = 0, _type$getInterfaces2 = type.getInterfaces(); _i4 < _type$getInterfaces2.length; _i4++) {\n          var iface = _type$getInterfaces2[_i4];\n\n          if (isInterfaceType(iface)) {\n            var impls = this._implementations[iface.name];\n\n            if (impls) {\n              impls.push(type);\n            } else {\n              this._implementations[iface.name] = [type];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var _proto = GraphQLSchema.prototype;\n\n  _proto.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  _proto.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  _proto.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  _proto.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  _proto.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (isUnionType(abstractType)) {\n      return abstractType.getTypes();\n    }\n\n    return this._implementations[abstractType.name] || [];\n  };\n\n  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    if (this._possibleTypeMap[abstractType.name] == null) {\n      var map = Object.create(null);\n\n      for (var _i6 = 0, _this$getPossibleType2 = this.getPossibleTypes(abstractType); _i6 < _this$getPossibleType2.length; _i6++) {\n        var type = _this$getPossibleType2[_i6];\n        map[type.name] = true;\n      }\n\n      this._possibleTypeMap[abstractType.name] = map;\n    }\n\n    return Boolean(this._possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n\n  _proto.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  _proto.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  _proto.toConfig = function toConfig() {\n    return {\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: objectValues(this.getTypeMap()),\n      directives: this.getDirectives().slice(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || [],\n      assumeValid: this.__validationErrors !== undefined,\n      allowedLegacyNames: this.__allowedLegacyNames\n    };\n  };\n\n  return GraphQLSchema;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLSchema);\n\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n\n  var namedType = getNamedType(type);\n  var seenType = map[namedType.name];\n\n  if (seenType) {\n    if (seenType !== namedType) {\n      throw new Error(\"Schema must contain uniquely named types but contains multiple types named \\\"\".concat(namedType.name, \"\\\".\"));\n    }\n\n    return map;\n  }\n\n  map[namedType.name] = namedType;\n  var reducedMap = map;\n\n  if (isUnionType(namedType)) {\n    reducedMap = namedType.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(namedType)) {\n    reducedMap = namedType.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(namedType) || isInterfaceType(namedType)) {\n    for (var _i8 = 0, _objectValues4 = objectValues(namedType.getFields()); _i8 < _objectValues4.length; _i8++) {\n      var field = _objectValues4[_i8];\n      var fieldArgTypes = field.args.map(function (arg) {\n        return arg.type;\n      });\n      reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    }\n  }\n\n  if (isInputObjectType(namedType)) {\n    for (var _i10 = 0, _objectValues6 = objectValues(namedType.getFields()); _i10 < _objectValues6.length; _i10++) {\n      var _field = _objectValues6[_i10];\n      reducedMap = typeMapReducer(reducedMap, _field.type);\n    }\n  }\n\n  return reducedMap;\n}\n\nfunction typeMapDirectiveReducer(map, directive) {\n  // Directives are not validated until validateSchema() is called.\n  if (!isDirective(directive)) {\n    return map;\n  }\n\n  return directive.args.reduce(function (_map, arg) {\n    return typeMapReducer(_map, arg.type);\n  }, map);\n}\n"]},"metadata":{},"sourceType":"module"}