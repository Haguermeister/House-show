{"ast":null,"code":"var _defKindToExtKind;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport didYouMean from '../../jsutils/didYouMean';\nimport suggestionList from '../../jsutils/suggestionList';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { Kind } from '../../language/kinds';\nimport { isTypeDefinitionNode } from '../../language/predicates';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from '../../type/definition';\nexport function extendingUnknownTypeMessage(typeName, suggestedTypes) {\n  return \"Cannot extend type \\\"\".concat(typeName, \"\\\" because it is not defined.\") + didYouMean(suggestedTypes.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  }));\n}\nexport function extendingDifferentTypeKindMessage(typeName, kind) {\n  return \"Cannot extend non-\".concat(kind, \" type \\\"\").concat(typeName, \"\\\".\");\n}\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\n\nexport function PossibleTypeExtensions(context) {\n  var schema = context.getSchema();\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n\n  function checkExtension(node) {\n    var typeName = node.name.value;\n    var defNode = definedTypes[typeName];\n    var existingType = schema && schema.getType(typeName);\n\n    if (defNode) {\n      var expectedKind = defKindToExtKind[defNode.kind];\n\n      if (expectedKind !== node.kind) {\n        context.reportError(new GraphQLError(extendingDifferentTypeKindMessage(typeName, extensionKindToTypeName(expectedKind)), [defNode, node]));\n      }\n    } else if (existingType) {\n      var _expectedKind = typeToExtKind(existingType);\n\n      if (_expectedKind !== node.kind) {\n        context.reportError(new GraphQLError(extendingDifferentTypeKindMessage(typeName, extensionKindToTypeName(_expectedKind)), node));\n      }\n    } else {\n      var allTypeNames = Object.keys(definedTypes);\n\n      if (schema) {\n        allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));\n      }\n\n      var suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(new GraphQLError(extendingUnknownTypeMessage(typeName, suggestedTypes), node.name));\n    }\n  }\n}\nvar defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, Kind.SCALAR_TYPE_DEFINITION, Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.UNION_TYPE_DEFINITION, Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INPUT_OBJECT_TYPE_DEFINITION, Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  } else if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  } else if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  } else if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  } else if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  } else if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n\n    default:\n      return 'unknown type';\n  }\n}","map":{"version":3,"sources":["/Users/austinhague/Full_Stack_UofR/Projects/shop-shop-till-you-drop/client/node_modules/graphql/validation/rules/PossibleTypeExtensions.mjs"],"names":["_defKindToExtKind","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","didYouMean","suggestionList","GraphQLError","Kind","isTypeDefinitionNode","isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","extendingUnknownTypeMessage","typeName","suggestedTypes","concat","map","x","extendingDifferentTypeKindMessage","kind","PossibleTypeExtensions","context","schema","getSchema","definedTypes","create","_i2","_context$getDocument$2","getDocument","definitions","length","def","name","ScalarTypeExtension","checkExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","node","defNode","existingType","getType","expectedKind","defKindToExtKind","reportError","extensionKindToTypeName","_expectedKind","typeToExtKind","allTypeNames","keys","getTypeMap","SCALAR_TYPE_DEFINITION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_DEFINITION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_DEFINITION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_DEFINITION","UNION_TYPE_EXTENSION","ENUM_TYPE_DEFINITION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_DEFINITION","INPUT_OBJECT_TYPE_EXTENSION","type"],"mappings":"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","sourcesContent":["var _defKindToExtKind;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport didYouMean from '../../jsutils/didYouMean';\nimport suggestionList from '../../jsutils/suggestionList';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { Kind } from '../../language/kinds';\nimport { isTypeDefinitionNode } from '../../language/predicates';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from '../../type/definition';\nexport function extendingUnknownTypeMessage(typeName, suggestedTypes) {\n  return \"Cannot extend type \\\"\".concat(typeName, \"\\\" because it is not defined.\") + didYouMean(suggestedTypes.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  }));\n}\nexport function extendingDifferentTypeKindMessage(typeName, kind) {\n  return \"Cannot extend non-\".concat(kind, \" type \\\"\").concat(typeName, \"\\\".\");\n}\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\n\nexport function PossibleTypeExtensions(context) {\n  var schema = context.getSchema();\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n\n  function checkExtension(node) {\n    var typeName = node.name.value;\n    var defNode = definedTypes[typeName];\n    var existingType = schema && schema.getType(typeName);\n\n    if (defNode) {\n      var expectedKind = defKindToExtKind[defNode.kind];\n\n      if (expectedKind !== node.kind) {\n        context.reportError(new GraphQLError(extendingDifferentTypeKindMessage(typeName, extensionKindToTypeName(expectedKind)), [defNode, node]));\n      }\n    } else if (existingType) {\n      var _expectedKind = typeToExtKind(existingType);\n\n      if (_expectedKind !== node.kind) {\n        context.reportError(new GraphQLError(extendingDifferentTypeKindMessage(typeName, extensionKindToTypeName(_expectedKind)), node));\n      }\n    } else {\n      var allTypeNames = Object.keys(definedTypes);\n\n      if (schema) {\n        allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));\n      }\n\n      var suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(new GraphQLError(extendingUnknownTypeMessage(typeName, suggestedTypes), node.name));\n    }\n  }\n}\nvar defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, Kind.SCALAR_TYPE_DEFINITION, Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.UNION_TYPE_DEFINITION, Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INPUT_OBJECT_TYPE_DEFINITION, Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  } else if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  } else if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  } else if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  } else if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  } else if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n\n    default:\n      return 'unknown type';\n  }\n}\n"]},"metadata":{},"sourceType":"module"}