{"ast":null,"code":"import find from '../polyfills/find';\nimport flatMap from '../polyfills/flatMap';\nimport objectValues from '../polyfills/objectValues';\nimport objectEntries from '../polyfills/objectEntries';\nimport inspect from '../jsutils/inspect';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isValidNameError } from '../utilities/assertValidName';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators';\nimport { isDirective } from './directives';\nimport { isIntrospectionType } from './introspection';\nimport { assertSchema } from './schema';\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isNonNullType, isInputType, isOutputType, isRequiredArgument } from './definition';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext = /*#__PURE__*/function () {\n  function SchemaValidationContext(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), getOperationTypeNode(schema, queryType, 'query'));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\n\nfunction getOperationTypeNode(schema, type, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n\n  for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {\n    var node = operationNodes[_i2];\n\n    if (node.operation === operation) {\n      return node.type;\n    }\n  }\n\n  return type.astNode;\n}\n\nfunction validateDirectives(context) {\n  for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {\n    var directive = _context$schema$getDi2[_i4]; // Ensure all directives are in fact GraphQL directives.\n\n    if (!isDirective(directive)) {\n      context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive && directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    var argNames = Object.create(null);\n\n    var _loop = function _loop(_i6, _directive$args2) {\n      var arg = _directive$args2[_i6];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure they are unique per directive.\n\n      if (argNames[argName]) {\n        context.reportError(\"Argument @\".concat(directive.name, \"(\").concat(argName, \":) can only be defined once.\"), directive.astNode && directive.args.filter(function (_ref) {\n          var name = _ref.name;\n          return name === argName;\n        }).map(function (_ref2) {\n          var astNode = _ref2.astNode;\n          return astNode;\n        }));\n        return \"continue\";\n      }\n\n      argNames[argName] = true; // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(argName, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), arg.astNode);\n      }\n    };\n\n    for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {\n      var _ret = _loop(_i6, _directive$args2);\n\n      if (_ret === \"continue\") continue;\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  } // Ensure names are valid, however introspection types opt out.\n\n\n  var error = isValidNameError(node.name, node.astNode || undefined);\n\n  if (error) {\n    context.addError(error);\n  }\n}\n\nfunction validateTypes(context) {\n  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  var typeMap = context.schema.getTypeMap();\n\n  for (var _i8 = 0, _objectValues2 = objectValues(typeMap); _i8 < _objectValues2.length; _i8++) {\n    var type = _objectValues2[_i8]; // Ensure all provided types are in fact GraphQL type.\n\n    if (!isNamedType(type)) {\n      context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type && type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateObjectInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  for (var _i10 = 0; _i10 < fields.length; _i10++) {\n    var field = fields[_i10]; // Ensure they are named correctly.\n\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n    } // Ensure the arguments are valid\n\n\n    var argNames = Object.create(null);\n\n    var _loop2 = function _loop2(_i12, _field$args2) {\n      var arg = _field$args2[_i12];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure they are unique per field.\n\n      if (argNames[argName]) {\n        context.reportError(\"Field argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) can only be defined once.\"), field.args.filter(function (_ref3) {\n          var name = _ref3.name;\n          return name === argName;\n        }).map(function (_ref4) {\n          var astNode = _ref4.astNode;\n          return astNode;\n        }));\n      }\n\n      argNames[argName] = true; // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), arg.astNode && arg.astNode.type);\n      }\n    };\n\n    for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {\n      _loop2(_i12, _field$args2);\n    }\n  }\n}\n\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n\n  for (var _i14 = 0, _object$getInterfaces2 = object.getInterfaces(); _i14 < _object$getInterfaces2.length; _i14++) {\n    var iface = _object$getInterfaces2[_i14];\n\n    if (!isInterfaceType(iface)) {\n      context.reportError(\"Type \".concat(inspect(object), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getAllImplementsInterfaceNodes(object, iface));\n      continue;\n    }\n\n    if (implementedTypeNames[iface.name]) {\n      context.reportError(\"Type \".concat(object.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(object, iface));\n      continue;\n    }\n\n    implementedTypeNames[iface.name] = true;\n    validateObjectImplementsInterface(context, object, iface);\n  }\n}\n\nfunction validateObjectImplementsInterface(context, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.\n\n  for (var _i16 = 0, _objectEntries2 = objectEntries(ifaceFieldMap); _i16 < _objectEntries2.length; _i16++) {\n    var _ref6 = _objectEntries2[_i16];\n    var fieldName = _ref6[0];\n    var ifaceField = _ref6[1];\n    var objectField = objectFieldMap[fieldName]; // Assert interface field exists on object.\n\n    if (!objectField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \").concat(object.name, \" does not provide it.\"), [ifaceField.astNode].concat(getAllNodes(object)));\n      continue;\n    } // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(object.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(objectField.type), \".\"), [ifaceField.astNode && ifaceField.astNode.type, objectField.astNode && objectField.astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _loop3 = function _loop3(_i18, _ifaceField$args2) {\n      var ifaceArg = _ifaceField$args2[_i18];\n      var argName = ifaceArg.name;\n      var objectArg = find(objectField.args, function (arg) {\n        return arg.name === argName;\n      }); // Assert interface field arg exists on object field.\n\n      if (!objectArg) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) expected but \").concat(object.name, \".\").concat(fieldName, \" does not provide it.\"), [ifaceArg.astNode, objectField.astNode]);\n        return \"continue\";\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n\n      if (!isEqualType(ifaceArg.type, objectArg.type)) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(object.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(objectArg.type), \".\"), [ifaceArg.astNode && ifaceArg.astNode.type, objectArg.astNode && objectArg.astNode.type]);\n      } // TODO: validate default values?\n\n    };\n\n    for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {\n      var _ret2 = _loop3(_i18, _ifaceField$args2);\n\n      if (_ret2 === \"continue\") continue;\n    } // Assert additional arguments must not be required.\n\n\n    var _loop4 = function _loop4(_i20, _objectField$args2) {\n      var objectArg = _objectField$args2[_i20];\n      var argName = objectArg.name;\n      var ifaceArg = find(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      if (!ifaceArg && isRequiredArgument(objectArg)) {\n        context.reportError(\"Object field \".concat(object.name, \".\").concat(fieldName, \" includes required argument \").concat(argName, \" that is missing from the Interface field \").concat(iface.name, \".\").concat(fieldName, \".\"), [objectArg.astNode, ifaceField.astNode]);\n      }\n    };\n\n    for (var _i20 = 0, _objectField$args2 = objectField.args; _i20 < _objectField$args2.length; _i20++) {\n      _loop4(_i20, _objectField$args2);\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n\n  for (var _i22 = 0; _i22 < memberTypes.length; _i22++) {\n    var memberType = memberTypes[_i22];\n\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include type \").concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  for (var _i24 = 0; _i24 < enumValues.length; _i24++) {\n    var enumValue = enumValues[_i24];\n    var valueName = enumValue.name; // Ensure valid name.\n\n    validateName(context, enumValue);\n\n    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n      context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  for (var _i26 = 0; _i26 < fields.length; _i26++) {\n    var field = fields[_i26]; // Ensure they are named correctly.\n\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  var fieldPath = []; // Position in the type path\n\n  var fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    var fields = objectValues(inputObj.getFields());\n\n    for (var _i28 = 0; _i28 < fields.length; _i28++) {\n      var field = fields[_i28];\n\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        var fieldType = field.type.ofType;\n        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          var cyclePath = fieldPath.slice(cycleIndex);\n          var pathStr = cyclePath.map(function (fieldObj) {\n            return fieldObj.name;\n          }).join('.');\n          context.reportError(\"Cannot reference Input Object \\\"\".concat(fieldType.name, \"\\\" within itself through a series of non-null fields: \\\"\").concat(pathStr, \"\\\".\"), cyclePath.map(function (fieldObj) {\n            return fieldObj.astNode;\n          }));\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  return flatMap(getAllNodes(object), function (item) {\n    return getter(item) || [];\n  });\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}","map":{"version":3,"sources":["/Users/austinhague/Full_Stack_UofR/Projects/House-show/client/node_modules/graphql/type/validate.mjs"],"names":["find","flatMap","objectValues","objectEntries","inspect","GraphQLError","isValidNameError","isEqualType","isTypeSubTypeOf","isDirective","isIntrospectionType","assertSchema","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNamedType","isNonNullType","isInputType","isOutputType","isRequiredArgument","validateSchema","schema","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","_errors","_proto","prototype","reportError","nodes","_nodes","Array","isArray","filter","Boolean","addError","push","queryType","getQueryType","astNode","concat","getOperationTypeNode","mutationType","getMutationType","subscriptionType","getSubscriptionType","type","operation","operationNodes","getAllSubNodes","node","operationTypes","_i2","_i4","_context$schema$getDi2","getDirectives","directive","validateName","argNames","Object","create","_loop","_i6","_directive$args2","arg","argName","name","args","_ref","_ref2","_ret","__allowedLegacyNames","indexOf","undefined","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","_i8","_objectValues2","validateFields","validateObjectInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","getAllNodes","_i10","field","_loop2","_i12","_field$args2","_ref3","_ref4","object","implementedTypeNames","_i14","_object$getInterfaces2","getInterfaces","iface","getAllImplementsInterfaceNodes","validateObjectImplementsInterface","objectFieldMap","ifaceFieldMap","_i16","_objectEntries2","_ref6","fieldName","ifaceField","objectField","_loop3","_i18","_ifaceField$args2","ifaceArg","objectArg","_ret2","_loop4","_i20","_objectField$args2","union","memberTypes","getTypes","includedTypeNames","_i22","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","_i24","enumValue","valueName","inputObj","_i26","visitedTypes","fieldPath","fieldPathIndexByTypeName","detectCycleRecursive","_i28","ofType","fieldType","cycleIndex","cyclePath","slice","pathStr","fieldObj","pop","extensionASTNodes","getter","item","typeNode","interfaces","ifaceNode","value","typeName","unionNode","types"],"mappings":"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","sourcesContent":["import find from '../polyfills/find';\nimport flatMap from '../polyfills/flatMap';\nimport objectValues from '../polyfills/objectValues';\nimport objectEntries from '../polyfills/objectEntries';\nimport inspect from '../jsutils/inspect';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isValidNameError } from '../utilities/assertValidName';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators';\nimport { isDirective } from './directives';\nimport { isIntrospectionType } from './introspection';\nimport { assertSchema } from './schema';\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isNonNullType, isInputType, isOutputType, isRequiredArgument } from './definition';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext =\n/*#__PURE__*/\nfunction () {\n  function SchemaValidationContext(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), getOperationTypeNode(schema, queryType, 'query'));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\n\nfunction getOperationTypeNode(schema, type, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n\n  for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {\n    var node = operationNodes[_i2];\n\n    if (node.operation === operation) {\n      return node.type;\n    }\n  }\n\n  return type.astNode;\n}\n\nfunction validateDirectives(context) {\n  for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {\n    var directive = _context$schema$getDi2[_i4];\n\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive && directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    var argNames = Object.create(null);\n\n    var _loop = function _loop(_i6, _directive$args2) {\n      var arg = _directive$args2[_i6];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure they are unique per directive.\n\n      if (argNames[argName]) {\n        context.reportError(\"Argument @\".concat(directive.name, \"(\").concat(argName, \":) can only be defined once.\"), directive.astNode && directive.args.filter(function (_ref) {\n          var name = _ref.name;\n          return name === argName;\n        }).map(function (_ref2) {\n          var astNode = _ref2.astNode;\n          return astNode;\n        }));\n        return \"continue\";\n      }\n\n      argNames[argName] = true; // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(argName, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), arg.astNode);\n      }\n    };\n\n    for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {\n      var _ret = _loop(_i6, _directive$args2);\n\n      if (_ret === \"continue\") continue;\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  } // Ensure names are valid, however introspection types opt out.\n\n\n  var error = isValidNameError(node.name, node.astNode || undefined);\n\n  if (error) {\n    context.addError(error);\n  }\n}\n\nfunction validateTypes(context) {\n  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  var typeMap = context.schema.getTypeMap();\n\n  for (var _i8 = 0, _objectValues2 = objectValues(typeMap); _i8 < _objectValues2.length; _i8++) {\n    var type = _objectValues2[_i8];\n\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type && type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateObjectInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  for (var _i10 = 0; _i10 < fields.length; _i10++) {\n    var field = fields[_i10];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n    } // Ensure the arguments are valid\n\n\n    var argNames = Object.create(null);\n\n    var _loop2 = function _loop2(_i12, _field$args2) {\n      var arg = _field$args2[_i12];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure they are unique per field.\n\n      if (argNames[argName]) {\n        context.reportError(\"Field argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) can only be defined once.\"), field.args.filter(function (_ref3) {\n          var name = _ref3.name;\n          return name === argName;\n        }).map(function (_ref4) {\n          var astNode = _ref4.astNode;\n          return astNode;\n        }));\n      }\n\n      argNames[argName] = true; // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), arg.astNode && arg.astNode.type);\n      }\n    };\n\n    for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {\n      _loop2(_i12, _field$args2);\n    }\n  }\n}\n\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n\n  for (var _i14 = 0, _object$getInterfaces2 = object.getInterfaces(); _i14 < _object$getInterfaces2.length; _i14++) {\n    var iface = _object$getInterfaces2[_i14];\n\n    if (!isInterfaceType(iface)) {\n      context.reportError(\"Type \".concat(inspect(object), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getAllImplementsInterfaceNodes(object, iface));\n      continue;\n    }\n\n    if (implementedTypeNames[iface.name]) {\n      context.reportError(\"Type \".concat(object.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(object, iface));\n      continue;\n    }\n\n    implementedTypeNames[iface.name] = true;\n    validateObjectImplementsInterface(context, object, iface);\n  }\n}\n\nfunction validateObjectImplementsInterface(context, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.\n\n  for (var _i16 = 0, _objectEntries2 = objectEntries(ifaceFieldMap); _i16 < _objectEntries2.length; _i16++) {\n    var _ref6 = _objectEntries2[_i16];\n    var fieldName = _ref6[0];\n    var ifaceField = _ref6[1];\n    var objectField = objectFieldMap[fieldName]; // Assert interface field exists on object.\n\n    if (!objectField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \").concat(object.name, \" does not provide it.\"), [ifaceField.astNode].concat(getAllNodes(object)));\n      continue;\n    } // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(object.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(objectField.type), \".\"), [ifaceField.astNode && ifaceField.astNode.type, objectField.astNode && objectField.astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _loop3 = function _loop3(_i18, _ifaceField$args2) {\n      var ifaceArg = _ifaceField$args2[_i18];\n      var argName = ifaceArg.name;\n      var objectArg = find(objectField.args, function (arg) {\n        return arg.name === argName;\n      }); // Assert interface field arg exists on object field.\n\n      if (!objectArg) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) expected but \").concat(object.name, \".\").concat(fieldName, \" does not provide it.\"), [ifaceArg.astNode, objectField.astNode]);\n        return \"continue\";\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n\n      if (!isEqualType(ifaceArg.type, objectArg.type)) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(object.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(objectArg.type), \".\"), [ifaceArg.astNode && ifaceArg.astNode.type, objectArg.astNode && objectArg.astNode.type]);\n      } // TODO: validate default values?\n\n    };\n\n    for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {\n      var _ret2 = _loop3(_i18, _ifaceField$args2);\n\n      if (_ret2 === \"continue\") continue;\n    } // Assert additional arguments must not be required.\n\n\n    var _loop4 = function _loop4(_i20, _objectField$args2) {\n      var objectArg = _objectField$args2[_i20];\n      var argName = objectArg.name;\n      var ifaceArg = find(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      if (!ifaceArg && isRequiredArgument(objectArg)) {\n        context.reportError(\"Object field \".concat(object.name, \".\").concat(fieldName, \" includes required argument \").concat(argName, \" that is missing from the Interface field \").concat(iface.name, \".\").concat(fieldName, \".\"), [objectArg.astNode, ifaceField.astNode]);\n      }\n    };\n\n    for (var _i20 = 0, _objectField$args2 = objectField.args; _i20 < _objectField$args2.length; _i20++) {\n      _loop4(_i20, _objectField$args2);\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n\n  for (var _i22 = 0; _i22 < memberTypes.length; _i22++) {\n    var memberType = memberTypes[_i22];\n\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include type \").concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  for (var _i24 = 0; _i24 < enumValues.length; _i24++) {\n    var enumValue = enumValues[_i24];\n    var valueName = enumValue.name; // Ensure valid name.\n\n    validateName(context, enumValue);\n\n    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n      context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  for (var _i26 = 0; _i26 < fields.length; _i26++) {\n    var field = fields[_i26];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  var fieldPath = []; // Position in the type path\n\n  var fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    var fields = objectValues(inputObj.getFields());\n\n    for (var _i28 = 0; _i28 < fields.length; _i28++) {\n      var field = fields[_i28];\n\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        var fieldType = field.type.ofType;\n        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          var cyclePath = fieldPath.slice(cycleIndex);\n          var pathStr = cyclePath.map(function (fieldObj) {\n            return fieldObj.name;\n          }).join('.');\n          context.reportError(\"Cannot reference Input Object \\\"\".concat(fieldType.name, \"\\\" within itself through a series of non-null fields: \\\"\").concat(pathStr, \"\\\".\"), cyclePath.map(function (fieldObj) {\n            return fieldObj.astNode;\n          }));\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  return flatMap(getAllNodes(object), function (item) {\n    return getter(item) || [];\n  });\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n"]},"metadata":{},"sourceType":"module"}