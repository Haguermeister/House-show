{"version":3,"file":"useQuery.js","sourceRoot":"","sources":["../../../src/react/hooks/useQuery.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\nimport { equal } from '@wry/equality';\n\nimport { mergeOptions, OperationVariables } from '../../core';\nimport { ApolloContextValue, getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloClient,\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\nimport { canUseWeakMap, isNonEmptyArray, maybeDeepFreeze } from '../../utilities';\n\nconst {\n  prototype: {\n    hasOwnProperty,\n  },\n} = Object;\n\nexport function useQuery<\n  TData = any,\n  TVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = Object.create(null),\n): QueryResult<TData, TVariables> {\n  return useInternalState(\n    useApolloClient(options.client),\n    query,\n  ).useQuery(options);\n}\n\nexport function useInternalState<TData, TVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n): InternalState<TData, TVariables> {\n  const stateRef = useRef<InternalState<TData, TVariables>>();\n  if (\n    !stateRef.current ||\n    client !== stateRef.current.client ||\n    query !== stateRef.current.query\n  ) {\n    stateRef.current = new InternalState(client, query);\n  }\n  const state = stateRef.current;\n\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n  const [_tick, setTick] = useState(0);\n  state.forceUpdate = () => {\n    setTick(tick => tick + 1);\n  };\n\n  return state;\n}\n\nclass InternalState<TData, TVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n  }\n\n  forceUpdate() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n  }\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    this.renderPromises = useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    const result = useSyncExternalStore(\n      useCallback(() => {\n        if (this.renderPromises) {\n          return () => {};\n        }\n\n        const onNext = () => {\n          const previousResult = this.result;\n          // We use `getCurrentResult()` instead of the onNext argument because\n          // the values differ slightly. Specifically, loading results will have\n          // an empty object for data instead of `undefined` for some reason.\n          const result = obsQuery.getCurrentResult();\n          // Make sure we're not attempting to re-render similar results\n          if (\n            previousResult &&\n            previousResult.loading === result.loading &&\n            previousResult.networkStatus === result.networkStatus &&\n            equal(previousResult.data, result.data)\n          ) {\n            return;\n          }\n\n          this.setResult(result);\n        };\n\n        const onError = (error: Error) => {\n          const last = obsQuery[\"last\"];\n          subscription.unsubscribe();\n          // Unfortunately, if `lastError` is set in the current\n          // `observableQuery` when the subscription is re-created,\n          // the subscription will immediately receive the error, which will\n          // cause it to terminate again. To avoid this, we first clear\n          // the last error/result from the `observableQuery` before re-starting\n          // the subscription, and restore it afterwards (so the subscription\n          // has a chance to stay open).\n          try {\n            obsQuery.resetLastResults();\n            subscription = obsQuery.subscribe(onNext, onError);\n          } finally {\n            obsQuery[\"last\"] = last;\n          }\n\n          if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n            // The error is not a GraphQL error\n            throw error;\n          }\n\n          const previousResult = this.result;\n          if (\n            !previousResult ||\n            (previousResult && previousResult.loading) ||\n            !equal(error, previousResult.error)\n          ) {\n            this.setResult({\n              data: (previousResult && previousResult.data) as TData,\n              error: error as ApolloError,\n              loading: false,\n              networkStatus: NetworkStatus.error,\n            });\n          }\n        };\n\n        let subscription = obsQuery.subscribe(onNext, onError);\n\n        return () => subscription.unsubscribe();\n      }, [\n        // We memoize the subscribe function using useCallback and the following\n        // dependency keys, because the subscribe function reference is all that\n        // useSyncExternalStore uses internally as a dependency key for the\n        // useEffect ultimately responsible for the subscription, so we are\n        // effectively passing this dependency array to that useEffect buried\n        // inside useSyncExternalStore, as desired.\n        obsQuery,\n        this.renderPromises,\n        this.client.disableNetworkFetches,\n      ]),\n\n      () => this.getCurrentResult(),\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    return this.toQueryResult(result);\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(\n    options: QueryHookOptions<TData, TVariables>,\n  ) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      this.queryHookOptions = options,\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n    let resolveFetchBlockingPromise: undefined | ((result: boolean) => any);\n\n    if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n      if (currentWatchQueryOptions && this.observable) {\n        // Though it might be tempting to postpone this setOptions call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that setOptions\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed). To prevent any risk of premature/unwanted\n        // network traffic, we use a fetchBlockingPromise, which will only be\n        // unblocked once the useEffect has fired.\n        this.observable.reobserve({\n          fetchBlockingPromise: new Promise<boolean>(resolve => {\n            resolveFetchBlockingPromise = resolve;\n          }),\n          // If watchQueryOptions.fetchBlockingPromise is also defined, it takes\n          // precedence over the fetchBlockingPromise we just created.\n          ...watchQueryOptions,\n        });\n\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    useUnblockFetchEffect(this.renderPromises, resolveFetchBlockingPromise);\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === 'standby'\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    displayName,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<TVariables, TData> {\n    // We use the mergeOptions helper function (which uses compact(...) and\n    // shallow-merges variables) to combine globalDefaults with any local\n    // defaultOptions provided to useQuery.\n    const toMerge: Partial<WatchQueryOptions<TVariables, TData>>[] = [];\n\n    // Merge global client.watchQuery default options with the lowest priority.\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    // Next, merge any defaultOptions passed directly to useQuery.\n    if (defaultOptions) toMerge.push(defaultOptions);\n\n    const latestOptions = this.observable && this.observable.options;\n    if (latestOptions && toMerge.length) {\n      // If we already have this.watchQueryOptions, those options should take\n      // precedence over default options of the same name. It might be simpler\n      // to do toMerge.push(this.watchQueryOptions), but that potentially\n      // (re)injects unrelated/unwanted options. Passing Object.create(null) as\n      // the second argument to toMerge.reduce ensures the result is a newly\n      // created object, so we can safely modify it in the forEach loop below.\n      const defaults = toMerge.reduce(mergeOptions, Object.create(null));\n\n      // Compact the toMerge array to hold only the merged defaults. This is\n      // equivalent to toMerge.splice(0, toMerge.length, defaults).\n      toMerge.length = 1;\n      toMerge[0] = defaults;\n\n      Object.keys(defaults).forEach(\n        (defaultOptionName: keyof WatchQueryOptions<TVariables, TData>) => {\n          const currentOptionValue = latestOptions[defaultOptionName];\n          if (\n            hasOwnProperty.call(latestOptions, defaultOptionName) &&\n            !equal(defaults[defaultOptionName], currentOptionValue)\n          ) {\n            // If you keep passing useQuery({ defaultOptions: { variables }}),\n            // those default variables continue to provide their default values\n            // every time, though in most cases this.watchQueryOptions.variables\n            // will have a current value for every default variable name, so the\n            // defaults don't matter. However, if a variable has been removed\n            // from this.watchQueryOptions.variables, future useQuery calls can\n            // restore its default value from defaultOptions.variables.\n            defaults[defaultOptionName] = defaultOptionName === \"variables\"\n              ? { ...defaults.variables, ...currentOptionValue }\n              : currentOptionValue;\n          }\n        },\n      );\n    }\n\n    // Give highest precedence to any non-default WatchQueryOptions passed\n    // directly to useQuery.\n    toMerge.push(otherOptions);\n\n    const merged = toMerge.reduce(mergeOptions, Object.create(null));\n\n    // This Object.assign is safe because merged is the fresh object created by\n    // the Object.create(null) argument to toMerge.reduce.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(merged, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (\n        watchQueryOptions.fetchPolicy === 'network-only' ||\n        watchQueryOptions.fetchPolicy === 'cache-and-network'\n      )\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    } else if (!watchQueryOptions.fetchPolicy) {\n      // We applied all available fetchPolicy default values above (from\n      // globalDefaults and defaultOptions), so, if fetchPolicy is still\n      // undefined, fall back to the default default (no typo), cache-first.\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    }\n\n    if (skip) {\n      const {\n        // The watchQueryOptions.initialFetchPolicy field usually defaults to\n        // watchQueryOptions.fetchPolicy, which has now been properly\n        // defaulted/initialized. However, watchQueryOptions.initialFetchPolicy\n        // can be provided explicitly instead, if more control is desired.\n        initialFetchPolicy = watchQueryOptions.fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: 'standby',\n      });\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    return watchQueryOptions;\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable: ObservableQuery<TData, TVariables>;\n  private obsQueryFields: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    let resolveFetchBlockingPromise: undefined | ((result: boolean) => any);\n\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = this.observable =\n      this.renderPromises\n        && this.renderPromises.getSSRObservable(this.watchQueryOptions)\n        || this.observable // Reuse this.observable if possible (and not SSR)\n        || this.client.watchQuery({\n          fetchBlockingPromise: new Promise<boolean>(resolve => {\n            resolveFetchBlockingPromise = resolve;\n          }),\n          ...this.watchQueryOptions,\n        });\n\n    useUnblockFetchEffect(this.renderPromises, resolveFetchBlockingPromise);\n\n    this.obsQueryFields = useMemo(() => ({\n      refetch: obsQuery.refetch.bind(obsQuery),\n      reobserve: obsQuery.reobserve.bind(obsQuery),\n      fetchMore: obsQuery.fetchMore.bind(obsQuery),\n      updateQuery: obsQuery.updateQuery.bind(obsQuery),\n      startPolling: obsQuery.startPolling.bind(obsQuery),\n      stopPolling: obsQuery.stopPolling.bind(obsQuery),\n      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n    }), [obsQuery]);\n\n    if (this.renderPromises) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      const ssrAllowed = !(\n        this.queryHookOptions.ssr === false ||\n        this.queryHookOptions.skip\n      );\n\n      if (ssrAllowed && obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult);\n  }\n\n  private handleErrorOrCompleted(result: ApolloQueryResult<TData>) {\n    if (!result.loading) {\n      if (result.error) {\n        this.onError(result.error);\n      } else if (result.data) {\n        this.onCompleted(result.data);\n      }\n    }\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        this.result = this.observable.getCurrentResult()\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>,\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(result, queryResult = {\n      data, // Ensure always defined, even if result.data is missing.\n      ...resultWithoutPartial,\n      ...this.obsQueryFields,\n      client: this.client,\n      observable: this.observable,\n      variables: this.observable.variables,\n      called: true,\n      previousData: this.previousData,\n    });\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== 'cache-only'\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n\nfunction useUnblockFetchEffect<TData, TVars>(\n  renderPromises: ApolloContextValue[\"renderPromises\"],\n  resolveFetchBlockingPromise?: (result: boolean) => any,\n) {\n  if (resolveFetchBlockingPromise) {\n    if (renderPromises) {\n      // Since we're doing SSR, the useEffect callback will not be called, so we\n      // must unblock the fetchBlockingPromise now.\n      resolveFetchBlockingPromise(true);\n    } else {\n      // Otherwise, silently discard blocked fetches whose useEffect callbacks\n      // have not fired within 5 seconds (more than enough time to mount).\n      setTimeout(() => resolveFetchBlockingPromise(false), 5000);\n    }\n  }\n\n  useEffect(() => {\n    if (resolveFetchBlockingPromise) {\n      resolveFetchBlockingPromise(true);\n    }\n  }, [resolveFetchBlockingPromise]);\n}\n"]}